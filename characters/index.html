<!DOCTYPE html>
<html class="staticrypt-html">

<head>
    <meta charset="utf-8" />
    <title>Docs Template Mugen - Wiki</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #ffffff;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"],
        input[type="text"] {
            background: inherit;
            border: 0;
            box-sizing: border-box;
            /* This ensures padding is included in the total width */
            font-size: 14px;
            outline: 0;
            padding: 15px 30px 15px 15px;
            /* Adjust the padding to ensure there is space for the icon */
            width: 100%;
        }

        .staticrypt-password-container {
            position: relative;
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            box-sizing: border-box;
        }

        .staticrypt-toggle-password-visibility {
            cursor: pointer;
            height: 20px;
            opacity: 60%;
            padding: 13px;
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background:
                #323a42;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #ffffff;
            font-size: 14px;
            cursor: pointer;
            border-radius: 30px;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover,
        .staticrypt-form .staticrypt-decrypt-button:active,
        .staticrypt-form .staticrypt-decrypt-button:focus {
            background:
                #323a42;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background:
                #343a40;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type="checkbox"] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border 0.75s linear infinite;
            animation: spinner-border 0.75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }

        .staticrypt-logo {
            margin: auto;
            width: 100px;
        }

        .staticrypt-logo img {
            width: 100%;
            height: auto;
        }
    </style>
</head>

<body class="staticrypt-body">
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
        <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
        <div class="staticrypt-page">
            <div class="staticrypt-form">
                <div class="staticrypt-logo">
                    <img alt="" src="./logo_icon.png" />
                </div>
                <div class="staticrypt-instructions">
                    <p class="staticrypt-title">Docs Template Mugen - Wiki</p>
                    <p>Enter the password</p>
                </div>

                <hr class="staticrypt-hr" />

                <form id="staticrypt-form" action="#" method="post">
                    <div class="staticrypt-password-container">
                        <input id="staticrypt-password" type="password" name="password"
                            placeholder="Password" autofocus />

                        <img class="staticrypt-toggle-password-visibility" alt="Show password"
                            title="Show password"
                            src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==" />
                    </div>

                    <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                        <input id="staticrypt-remember" type="checkbox" name="remember" checked />
                        Remember me
                    </label>

                    <input type="submit" class="staticrypt-decrypt-button" value="ENTER" />
                </form>
            </div>
        </div>
    </div>

    <script>
        // these variables will be filled when generating the file - the template format is 'variable_name'
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "Bad password!",
            templateToggleAltShow = "Show password",
            templateToggleAltHide = "Hide password",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"69ca3d835ae1855623e3ad8a24b6c1803d09e5d4747c4049f11430c65e0de593f38c01d8213231f70c66f349bca53ee9ae5f442069afcc80f2d143ce5b79021ec2a2cf9d63167ce8384e1611d97b794169e2338592a383dcf945ac9cfa3c0883dd2430e04725c49bf5d0f6b557ee6bc50c0e31dffde5f0c82c54f5859e5d4f1234bcd723db4f12651671aaf04972235bdf77dd4cdf603ff7242f5c7dc015dc5822ee792b0d33d2a921d1304b34469d200d00268bcd403fe2f9acd1ac4e6e3949384cba2fb21ed04a9d5a5e5a9a727076c42a8e3438ef5a31d3763765dc27081c5564bd1f9ac7bb63760b2ffd47a69247f39b51284c9ae63c6591f3d94454391ac0a03e22c5383ac48ee0b83417875bf87852decd460b6a99385aaf16f41bfc10d2d0eb82e820575aa6dcf6fba204b73f8f3611c279c56316d43d51430ee142389c99769c0badb96d3f30b18aca1a9d7905ca98d70818a87682887dc4a716e020811bedb94b1727a9b079224c266b243dc538bbcdb7040e73240fee18e1a9c328601de59b61b2d30716862e970050a7ad5067466c77c7d84e2abb3d209f0156bebb5213d840d6097057e765062f6f3d5285eb00d74cce011cca26da822ab2c38d26776334264267f3d80811bc187f1acebc5954762d8d245f156eb48f0def1aba9aea9a665437aa38b1526bc5b71b2d0a125cee46c780bc6ea715913dab818dee0f3cf5077fc1eb40d75c823977ebc7c97fd94dfdb6ac7bc64230f36aa7a15e0e01343eb5aa137a28244dcfda381bcee024c1571db9bfe8fa2f9e39501048db5e74d899530d8cc1e07e6c07da7cafdfe6c35335b6ba432ea0db0f07321032641dace5d12cb7c501f9efc9a83905876a264b885d583e92ba35616ea89d79a4c265a13ce1eb135aeb06c8f7da4a5adfa1a3409dffcc8e96d3bc321ef2d849645d033cc2f8e10b786dfe87fd6d418c1e7a0b5a22f48cc5457cb0aa7dc2bcdf7fa0b072a4469eb053638cea20de948f62a72112f044a2c2464f376891fd0bf5659ec24c177b6676c5e2c73442c8049ab3e051b315b5cbf22f5657702215c937f94491107938d8fffec20fc73cad5b8bfd1fdaaad02262826eb65a4b060514d5de64eedcad0038d3d3c328cfaba91f42c094f69ea63515978892c13202757cda7cf879192642d5a5e07763ac873c935064fe0ec97202f505c6e43f948119954ae8f839a98781e8de91aa6820cb7c394df855845dae49501d6101863249b2ec756e14c8945be12c625e0495920eeef3abd01a5350f928f3536c03c6900d2665cb989c0362fd914820c5858ce1dbb2a1b0a880c14868af5fca28104a7378084253be2447d0282abb50516eb33dbbd1150a4c3e991b841446aab942fa5cf03726a27d7df7e47bd4924b1c7ba58160a332587417833e0bfe103f15d58405c9c7e2477f24a35505ce34abc5c3d6a728ae17e4cf944905d8901a2998d03068b1735e6c3ac900292551bcae5462b000d272556619751d7b3ff6cb4ff0c666247175104995422ca4db34c8e134b45ac98d3619942ce4448197826acd872f2475fb217867d459d0d5f6abbd3b3151ad54744e9fb2c800a4c1aa90119744bfb59732f23dcfbd98366f32987a1353f7a7b8a5abf81ee21ff6846fbad034909782b47106afda0a9c367f5dcda23052285c994c7d5fd5965c7f2c77e140a6726685dd273c99889f08cef8105c9d0fe3b53a625871676792968d4dee4faf05ce77d6623b066e38466a94baf233d9d247545b34e251ff36c747d283430d27c0b58f68385af52eb1471bcf3b614becdce2f40a4315eab2612bf8fe058cf8734f5bb6563afd7f31dc16eaf609f6de311eb183289b24143bfd9a91271344df46bb40aa87f636e58290198f02226281a5aaf0cf2a1a0f3cd9b8a1223441124247bccf62280f165dd1ada24935dccea910b085ed206e75cf0da8d674f6a36d2ddf61a62767dcf9929fea0bbe47937b1ba0dd67ed398f7461d9c23dd08e23fd941fa7ee43164f7579ed1b4ed3b1253d512c9059d6d5c32bb1f78608ab42472e339cb524ad168d97f905a0946bd9c8a987195851331789a0c4e4ec87288bb90929310eaaceeb4ac104c04245ab44f6614abe75e67a77b7d08ac19f128529e41de363c1f2ab5e6288ef7500ed873046e81fc5d49c9a465fc4e35fd0fac54673ab77c53d0c8e45d4b8f4b04f3fa0e51188cd619ab927c570d27a832c7e179f744cd92b5711b4bed4b02c959380ef655ad0d5fbe46b8480badb34f82da6b5a97190d3395596e0e5e4af870c992392bce8ce30a79c2508e96d4797792ac5138806435d3c52a0354d0c247b23661cab167d3c989253af5de4b26c2a5b12e9c669f144650e9a797694167292163b9cfa6a59290ca830171abe3741b53ca28883a3e62831d0ee7e00d19c576d930da82a0e1484682479d21319569d10351fc58c9e571ac3cc57ffbda0a6de99a2d27d926fc589e1144817136a5f04799e7be7a0113a839ca66787772b8421ff88c13cbe5e5fa097b13bd5375f23e64eb4d1329f3dd83ddd01d3fae0763c418a8fcedf5d8dea517ea39be23d2ef886446e5b13397c69a5787aeeb5700f320931e9e20f2a8ccc3d8d6add702b18e15f35f8c42a7e66bf9f84ad1ff23304757f834bbe0c658b9ed50c98f1500511727673ff9194a4918a8c856c21e943d7ca9626e114376f1e078e6d1328602d060a1cdfdafe1911093bab102bbff28224b7736e74d7d8f4cbf1773a379157fe6d355b2ce44cf3776d931a2a1cae482d78c78e15312769fd995105c66e8aa8ac10f213c44e9b896aae4c9f126d73e035e79273aaa3bec3945a066e3ad8b25c5a6be430d7d819ff60012415eee51137fd3f8c2ddf4f26acea4de490af81a89e7f79c477b4f1078bd957002deeb33d80a48345eab0abdd8cee6ba5fef4af2cb949b454f94721cf3f58b518c1512e8ff7ad26735639f9ee9029a7b6e343d929ada3d177966f2c706ecbec0cf31d079b02c86dc1bf86c03829333795357490fc86bb5eb8aff881a3927227491224100d70ce119c66df3ec53b1239f1cae1fff70b127b810a930d06d7719fda012d0764a9cec006016cde48ad9a25107b80c79854efe97187d8b91edf85018671d08d791546ec85e08622f4cbc4cd5589c1b2e02887e04cd64430f0c874e4e5f46788146eb6f66983ce50f7838c9092f6861959a507614822d89ccc5ab7e3a04865246689bfd334e530cf3ea52f6017ac101eda55268b7725ced796c53a697b44c032baccd93c65dc430f45e58b1fc3e8eac16fcf2c7d968780c92ae1e5b3803ee8e4dac2de8a6d7520a6e8721ec65534544ca0083c191113f25011aba09dfcc63c07c3d8681ca62abbb9194a8700f9778d5b53e10c1b54b2a4e260afbd1c37aaa9d453f1c6403a28705748d7bd503157f19347225349158f2cd6e361e9f4771ecd881469160357c33c2b917ec2c21e8973753116831f27a9498e23b06afa0252f0474113df5420853fdfaa315b18f6475f1199163ece7752e15ab8fdf7e5d80c2d494e8b29b21e5374b2e3b1548a45506603bb0bc985e40d0b751702a886a54b3dbe8a2b918fac23c56319b369110fa9b857135bd352745d9ad7aaecc629156f3f1f996c2e6b7a2e5e932edaa7153db78aae93d2da587eeb65acb36eb1497c8c0a30ef8116282c8590d42f4c45845fe65c968af733bfd89868577ed813e5168b937c5f452cbc0c8c7ce03e0b01be598f62c94793d5f814702889ae967a0b935970afd2a6e68e07c6eb65653e4f9644734902c7f585d37087bdec683a342fb3e5a72fde62a540048e7ae3eb2c6ea0f1fc37bbe4ed39d9527922559fed31f62d653619b1515996156a4234824be4590fbc4fe6d6033c65d630d1a769dae304f81e7c7beca18e4f3f6eddc070b30aa90ce21880185f78f385395b3fc35ea8987be783b1755e82311e3b8dae5e8217aa5bc22c1c360b1c5e8050fda67b8dd86c4680ceebe33cc6240d2c582e4540b0d3bb6a4c18fd56155a29bdb79753572343cf68965b6e6ddd23de339da1fc574dd7191f39f14454b56ebd99f81fd8934c57f20f61dd6718469ca0076fdf40c04c5bea2ce57e58fd15109dbae3c598f7fee2ba7940b19ab92939302914173364f893b6ccd5242639296b943c94c6238b3c038adb9ff2bcd03b0c9c87ca7c04fc27a0596adf8d4e6fd9e98caef71a2426091e8914465be4963b43c6a4d57331685681703aab206d6dbf0a277e5db3b365001dc0ff140de9b80338769e3fc9fccbb57ac80ec7ae9c1babbda63c766cdf64064dab60e8ee01b0d7bb15dca795503b5e82b48604fb80204ce25cb3bdcf989fc90491541778299aa57ca92cbf4227e76854725b426e36ead44e509f315d54493fe72a101184d3016778fded34ad0979a4e6291ebb6157004bd2e41551d0a0b1002093132ae1e43980418a46ca55b3baa68fa5a84dcd57b3d76207aecf72b11600a773c2b57ff6553b05f72360afd4d00114f1308d90bebcc43e033d69ab7f3e0b8d37af0334426ddee795200147d8119eb0a34a2546b8903c04b4b1a92b975f15ca196f9a299c11b2697978f609781a661bd84095418ae134c4d8659fb15abdb0a9d62362bbd9e99e58a391ffd01e0fe150a14529fa44f4dcd616f1a6ed549080347f5f684df12c4dc14f90dc0d5388f2f437bd3543317302fb6d70e6bf6449375ca4b577bbd8bf6f1f8e307292c4cddad453a3f52ab7e851c1f023c88698f1161c586294275c3be0880f765238b5a12640c89d9aab2045f3d6f91dd01da4796ee8e32b28b84a006d650c4b0dc47075c31f04f35448745c86c00e78365928e5cfd05c0b30b91795a7eb79d2ac3ba46820cffa466442fe118d98ec54b6bc9db02583ae3d46c3d6525259be9ea8eb3f601c768dbe97e29a16258fad6178dd96e7f4fab6d14f61f585c4c3085aceeaf99143242a65f086b24ffa8f5c906b063817d18a5511be50ef9db3638b90ff6ce0533be92087cb2c0ce93a4baff1210e2935cbc3459968048b95460852af214030b4b3ac6bd76129f40a112fdb734b3e3354a43e33ce99c9add55d5f99e54262299bbc82e3d463fae9252a3c0c44d12b01a13d8eb89f20c304b27d5248c06202af0b98b55ab9f3da1aa523c10b29f52375bab2f52b8bb242e6b1f074038963b0e1d8d20d0370aa77a87301536d177e7d7a8f44712d138d97547f0bf508b1a8f575315bea34c2870d0a0e9c0d4fec3d6b38dece64fe82aaa189a9fd23f05002e2c0a77bb2281b672b11d6884634007bee1f3a1ae19882219fd47662c511daf00a0f7c4dfd9d303aef529adfd25662963dc27e310980c46e7a439628b0fc8bc0f48a7978e89bef6ebe5cb2fd92701528d22f4b5b359920b7728b61e559816c82db1710be73cd2a25cac6c4923e9da8cf3ccb1de33d15cde38dd3022eef3ebeee4a00e4847bc66bc5de266b74781800581ae6788453bae2599039805dd8f74358670d5795c80b8708950f7cb23bfa20b6504ce91f2b7102e34e32a0b68ddd1f28e26f7ff6ece5044026235b28d518a8cdd4d5188fb728006ea445131d391cdf8dfff05270176e7bf52ed6919bcaf199b2b02ec7af450fe1ae616d3e6e832a874811a5273163815d6c00428037f382ae9a70ba1988bc5e648a8525c79d85a5d459b8a1092e72d0310e76e014cb8ffc1024850dcade4e865c269060b597ae61ef10820cb4c212264abc30deca519521141632a0af23691eab2f3817fabd7e13bef68b622b31e492108d521282c38e0a49e5caf237b186908d36268593d010994e9e1aaa5a0ce35c445925944b82c85dbba6def80051c521aa940f3d53f1ccbd63caeb5ee458f966db8fb74fc7e8a1de01fa8338ce8a022ad21febaefb2a83cc0e969c212bf7787944482f8c96e42296f62b7e430bed5e6f72f7e5bab82f371847bb0d1897192fbec9f2331b87b3166fd3c8642e0fe031bf346a70dc43772248b8086dd1b3c6932390deb83c01857b8b35f9255c44ac91ec5907d2ffda587ba4b5d9c6fa36ae14c60a9829ab0e3775c9b6a9c7a46ecf4cebd323feb86f1e9afe490daeb387b97fe98e09490df1dd07a4088401750e356772ce9966a4fb08cec18ba45dcc3cb785ad59dd5658405cdddef9f100ccd527380269af774aeffa170b11fc67458734cdbc5c58a03bfcd060c333e45295d8c8faf5ddfe095d737121e81da0a1cce79f50e531067321f82df4f35c5a4ead5a7431043e8f2a7fb8f8b6bd2325aabe2823ad3087efae5fc1f2a242ccea11990cfd6419944e2002b7e14d05e283a4bf963c99d9a2821ab322cbc7630609057a01fe5ffba3be6428efd54bdf6c7956a11080f0b7697a6ad0500567afa5f50d9cc4bfaf0774ac8a5be814ada9f98be81595fbb342b11cbd84f655816f8da00d14fe5c726359792de7ce0750caaeff0f550f17625c2009a41971274ab6d98e6d00a10b607e52850b66878492dce3adec4e0ad6d0f32b6f1de9b3b4d3707aba05d2967010bb89f6447b85b77e6b22b27fbe28c94a653e229b159e08f708478228c86ddf9a918b0407a6f79ba834ca9d852e1bdd1bb84370ab7119bfdf615ba62da2df7caa461c0720154c5e7e02c53715f3a711aad95b1934869ee08662cbd87c84be6d438c99aff2b25317c9b92dc3c06b77b9e7f6e1f89af6e4b15eb0d2ff1d53e109df397b9c595b5f31050d9d47e2037a0b90f5f8012844676a8b01171808d15b69831892f9ea31177033522326d2c0cebad3bd5f63931e33d455f4ff8726421eda64b3541b77b024df91258a7919ba6e0cb79fe799b84de11eb12d5b231e17b9f1a01ff5d704dfe76eccd577a40a105ced95c39fbb67ba2a94b263ed18dfc931db4d6d4060823afb85a6ce8dcfb57ca413514dc45900e655d59aa2602064ce0da1a0e7668624ea8f64df3a36a12025217990210ee42b22f28abc51181ce6d79f684f2f071360417b7118e5c845113cacb020ea78de9f645232017640c217cfa4b88b790af9406d3d2be7eabf367da2fb26120570ac5ede07a038960a42a4712815c658d5485ede5ec0246c759ede28af51308b3d9bb35447a8089824e6aeac019da43a39d79fa8db80c5084ec852342488d43f6135c7c8bbb8e70bf56752035166fab6a81ac710ecac4ce03503cdc5bb120487e18d67deebc1a66cdc7c0356f592f8","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"34070fb5d5b87e29aac5291a9c26cb19"};

        // you can edit these values to customize some of the behavior of StatiCrypt
        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        // init the staticrypt engine
        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        // try to automatically decrypt on load if there is a saved password
        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

            // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
            // replaced, no need to do anything
            if (!isSuccessful) {
                // hide loading screen
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();

                // show the remember me checkbox
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // toggle password visibility
        const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
        // these two icons are coming from FontAwesome
        const imgSrcEyeClosed =
            "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
        const imgSrcEyeOpened =
            "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
        toggleIcon.addEventListener("click", function () {
            const passwordInput = document.getElementById("staticrypt-password");
            if (passwordInput.type === "password") {
                passwordInput.type = "text";
                toggleIcon.src = imgSrcEyeOpened;
                toggleIcon.alt = templateToggleAltHide;
                toggleIcon.title = templateToggleAltHide;
            } else {
                passwordInput.type = "password";
                toggleIcon.src = imgSrcEyeClosed;
                toggleIcon.alt = templateToggleAltShow;
                toggleIcon.title = templateToggleAltShow;
            }
        });

        // handle password form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();

            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;

            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>

</html>
