<!DOCTYPE html>
<html class="staticrypt-html">

<head>
    <meta charset="utf-8" />
    <title>Docs Template Mugen - Wiki</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #ffffff;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"],
        input[type="text"] {
            background: inherit;
            border: 0;
            box-sizing: border-box;
            /* This ensures padding is included in the total width */
            font-size: 14px;
            outline: 0;
            padding: 15px 30px 15px 15px;
            /* Adjust the padding to ensure there is space for the icon */
            width: 100%;
        }

        .staticrypt-password-container {
            position: relative;
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            box-sizing: border-box;
        }

        .staticrypt-toggle-password-visibility {
            cursor: pointer;
            height: 20px;
            opacity: 60%;
            padding: 13px;
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background:
                #323a42;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #ffffff;
            font-size: 14px;
            cursor: pointer;
            border-radius: 30px;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover,
        .staticrypt-form .staticrypt-decrypt-button:active,
        .staticrypt-form .staticrypt-decrypt-button:focus {
            background:
                #323a42;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background:
                #343a40;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type="checkbox"] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border 0.75s linear infinite;
            animation: spinner-border 0.75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }

        .staticrypt-logo {
            margin: auto;
            width: 100px;
        }

        .staticrypt-logo img {
            width: 100%;
            height: auto;
        }
    </style>
</head>

<body class="staticrypt-body">
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
        <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
        <div class="staticrypt-page">
            <div class="staticrypt-form">
                <div class="staticrypt-logo">
                    <img alt="" src="./logo_icon.png" />
                </div>
                <div class="staticrypt-instructions">
                    <p class="staticrypt-title">Docs Template Mugen - Wiki</p>
                    <p>Enter the password</p>
                </div>

                <hr class="staticrypt-hr" />

                <form id="staticrypt-form" action="#" method="post">
                    <div class="staticrypt-password-container">
                        <input id="staticrypt-password" type="password" name="password"
                            placeholder="Password" autofocus />

                        <img class="staticrypt-toggle-password-visibility" alt="Show password"
                            title="Show password"
                            src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==" />
                    </div>

                    <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                        <input id="staticrypt-remember" type="checkbox" name="remember" checked />
                        Remember me
                    </label>

                    <input type="submit" class="staticrypt-decrypt-button" value="ENTER" />
                </form>
            </div>
        </div>
    </div>

    <script>
        // these variables will be filled when generating the file - the template format is 'variable_name'
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "Bad password!",
            templateToggleAltShow = "Show password",
            templateToggleAltHide = "Hide password",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6923d52db7ab5e1d5094424f4507bedb7d88756f54872a5e5db732e83c1315a3a3a453ea327c4992dd2e56cde20268bd31dc99413bfc61fe0a46d0b18f3e1fa555b18332cf7e6c27e50c2c63d807876b3bec1c383aab3efa99f45ebbbcd825a31c862a7307ed1295121a8e3d4f4152635534ccf6461a7d960d284fe1b413d378ea27f40ffcc42c75f03b50fadacd13fc50d3e2f5aac92dd12bbb2d7f9fb75a37fec83782bc578f165283127f7176d2416048944ad3a648039283bff2cbe9fc84034602e6b4d8d6ed516369f0f1331f0a1dd8765a23e7022732bc33d48f9e421fd1529768a3a21df03267a37e6ba26d3e10e7b60b4d28374a0c4878f7b5c88b53eb2545e527225f1470af8d32f6d2ae3a18737b8d974a8aab1819ea7c212e423fd73f5a2aee2b25db13798c263c77d42ae2f4de72ebb5d81872c36168be2fe7651c664d1cb9ccdf6d680b1f7a0a2eaa70d6bcd49618b833648b4213c243762fada81084106fabac7eb50e8d2fddc75bb54ff306555264355ab3a7a4fa0cae478bed270af514ad07bc4fd1e94a780a78f939543dcfdb39db3d532604b298479eb88525adce10878dfc5097223bb1b78459fcf6f6999c409d76a378d1109115369cc6c3690822125a6d4d50a4606569b31a66bda16f2aa5818b8bd5075a7bd0600b744fe82ca8f7d87dbe6219c498f828bc5a477ba20d12c52e8fb6cfa8f3ece07a4c41782077ae423e64fbac3ce7dadce2e4010f083c59b404f7dfecdfa3a29bf46575b9b4df54014fd1f03977924a11c9abfb4c7b67fa00a9c5e097e2c0a793c40b1827fad37e067234e1c3db5a724d41506c28624ec2a0f8dfe9c531097bb17d2d067ffc18b9cf957e0c83c86b70c562e93556e41c09efef1a8a37f672dae2176eeb4bda9d50f5a82252c07217f508066a461d15bcf2f94f14183bb011f56d312ebb5553ed9d20bf5f155904d1c23c9042a2a53416cb2d109aa935b55c7e8d87d37a77c22849cba925a55df7fba43c322c87a548c4d176057c3134f51f4208ce7b937e4088ec4cf871c0841a55b2a676ab42ccd40d8dc841d4875d74dce0adf38fa3b0c37513befa3976a582105f22efdddd428f19d428ec2592cd3e31b80f778480371f235c55028ee4c078e85b6c9b96cba4f211d25bf286b15e333d7a747d74cf677036d135dfb3ae2ead3ad6dcfd50c7589c91a7567a467cbaf63294b24f3cbc55b056d17b531d5f0b22285a68312c2e4c4a4f4aee87c533c853f70db9d23e8a63a880fb805b60df8362dfb52e8f4d7852b29ac634c49f832e0bb18a735ef1e72d508a0b1c3e4d2823cb82c32979e5fdd9646bc84c06e1a26df483589db2c26d39f327599a9efcb5cbae81f89e1ad1ee7da7c6037787f4459a0d4bf55535087a50e0287e13c18fa5534ded98fc2db38fb423187f05c5229df11bdd02e2239fe76d9aca9d97e37920e543b764924ab0782d4f93467d9bb8c5a796f7e0f7b2213bef0d997b0de05daa9c12fb23151eb10c8126a65af05e8634ec407a86c83cb7a0a47ddedb4c0e779049c123d903f4aba8a163c0b6ae4a57c79e4cfb7bdc764475e8e4757c6bad792f9e02aa00e2393501da840a9fd0edfbca3b33fb21a876f79270836ee271cd83ac8424310d5fe50b8ba16f1be5bff36d5cf8c2f23ea46b48546189687449773389eebe7baeb81fb34d04750577cda3874eea26fbb8171aa77743785b625bc2fa3f646933fa1278df52e964056d53cd297a3c5feb81c883d96d00874bc311feafd8a71b71c2cbcb6362a982968a2c20af9b71e53f988c51cd2ab39d6628a7b1d24c66b127e2fbc1c20ee82485e6fa4aad19c91f7f8794035d8670063b0f4b566e0acb5028a3e8ec799a28403e2999fce40293bc0a59d0da8131c886d55844105a2155551602045a31fe2efd179cfe07602640d4d446e55458cbc83c4fc3709fac2f9faaf9ffc9ce8b42e678917a5a54f2f2218e4226250c4e09bfa2828f4526e6ef074b25bb7d7c5f6b2286d4d12a0ab7d22e97ba4a1380ef38fe39ccd4b4d32c57a3885654d0d50b541320c11d3460045def125e15fe1d23d67c4eb2e50a0d819a3045242f31ebf8269e127e8c4c3219471cd249969f8f6214584212b91f6419892cd1eddaa3ee96b24c022a7f34f883c4c0943a414e41758580eec79656542aa918df282b2f78ba95929b23388eb1b5bdca03b4d4adb559ac700c713594809856c7cd8f1e93a6a36ceb73030db00a36e2fc06841f10f508951b5f148ca37ca1a7e1f7d89bbe34b4fd686243c22eca4c94b2da61fb2776aaf2f85cf5ae70c65d431ae4ea5859689faef8a4c2910012987ff11490fa3a5d26edb5168235714f83564125922fdff0aed89297deadd63d1980163a511ac0380f66b2dcd624cfa76eca8498c88d599c1393c56fbf0f86e2e21ce50b33dfe25a6912c16c19e1b5ba30925ef310061d76cd7d80a1aca95d0215acc26b69a260f9be1f94039fdf0eed337efa877db605981501687f1fa66b6e5f76e9a580f680b65fcc657627872987706db53c752329220003662fe1e609f8e32a789a9253b4a59e05530bea1fa7cf243864081b6d3cd78aed00372a2e4877ea2794762314f64134b50485601a120974c79e3b0f567483affb1d36fa19d99a180b923db12feb6f6923dddecf61851638f9745d23e335aa122d612d2f2665f485fcd2abb97ecdc376333cdc5cbbe0af1781e3a344da8bbf0955b5e49a93f8a493675e92812aff0e8cc6102297a91319c52b06b41e82a15d4c6051e9643b0140964af33b780a24b50073f3de2c40734b6d2bc94a298e9913d41f44d2342eb438b554c406888e6c7c961540137b10033a27ba02956c6f348eb7c9a9de85a58cfcf7ca1946f0a87f446faf51e1a18b9ac47d4a8056750d4b7a72957c6b8aac96638cbcaaae7706f205144c275798d6fb9e642598e2167362238acd70562ca7ceb673ff87d21fada7b004d819ba484a4ffb60911cba8d07340d6a04b6cecd9d00708762544f7a1403df3de1184f9ff4fd4c320c22812751597bc9835053fddafe78cab4947a6a5c23a86a27a9da2c5cb078028aa0ad477dfb42baa5a9b294fc54f65db5a6b9cae2ec84986233743ffb96856653fd77150b0b56bfeb5c9c5a9d8455d9a7e4e644a84a3eef4ab0812045d1c0fa575cac956dd2769e53a332eabf2173df5eb5801207fb7bed6437e53ad0b7a199919f3b219b2add5f17798d54ac3aadfc1329efa5cbf93db47763cf12d2fef9e0ac9fcbae192c40daa07c0979a15172998771e5341f902cd4d3b2b8f828d5d755d805e1391e8601c668b2c9d7c7c2c64ea9929fc2a3c4c779c0f3075c4f4b0e9cc218633f34765a888a73d89461f8a3b4399e4bf0114648958eb44a5878d899d3787156030331e7a844b25a1d0441bb6e5723260d39328c2d83b3b9066debc3c18e4d01c9da5d7075f64cf3437f9523d64bfc19d5d9a59513deecce8349d096d20e089d063de5f2743c73d44faa80455718254bdd917c0f247d8aa13540bea1665a24b7e7ac0ac852f1bf98e29428c6db3968c346458b8e6bca272bb99c203077e5b4c56a7ba9f22e6ac90000fc9030c35f5d26e491a27011d64bf86e7b5fbafb7689e95edbb1bfad263ec4425b27fe7981f06eed370a281dd4f6622c34bc55bd0428af942d3e21365b00e0bbd93a8102100cfc933acef0f88b46d8d686eed4e0e968731d9a063f8810d62c4a5da6ad862d85707ffc423291aed606388e9be15fe15f8850206bb4fe096b9ca5009517b9695c48a2de0a8a4fa1c5310768d15a681fd393f317f5d9a264347f304332be75105bf354fa2df5c5372ad372a92df95a1fb78c85ddd43c6275515db3087120124058536a54cc6f5e295e5dcdb8c140b55f241139a09fa0f3257bfe28163016b9b976ace5084776511b09980625f3f9d187e1ff491d61d7e23c243cd5f26369dd626f2b6da646f3d3cc897f3154e096a4ce1068a87ec32055ba35614b5519a6c31d79ae63f22f6c5e2ed0dba24e7d4cb777237e7fa4d8a2df450b757a515d755388da63afe99fedeab5632c8e3700bc356f67d0bf5a9f98f0f5031e91717d936c76b9cf6fda763fdba40cf9f68795437d0ae023da63a05058bb6277d2d00b4480823d83073a9d86dc12dd9facf9b371717c2f9ccdf73bf314b9811894f68129b10d45f820d47ceb9983f47b9d981d8452daae61e5180bd6907b9932c8d183d004d5beaa0c4a20e6ce779deb285ed7ba477eacfd17f716c84aa530c26e03c7fbdd2ba784e8265e0146bcebdce21437cb4e8f0aa2d73af11164056c3fa89da90d11f5d56201152e53f2e522eaa6b6d852bb2e94292651fd53c6d80b8eb58f5963b3ef700d1d0af2515cea16d040fa23f5bf57b4a8a2dfca1d78939ec0ad9c1282573710837eef0583f7a79d07259dd36a4f79fb422d88af2f398caad2745dcc1d8387f2a7bf67a0967fd45ad7bba4bab4876d645c4bbab2a0572af4c3460e196d8692adedb4d31df175dea93b314bc0ab09542a3cd921a4e7b8991e44c7153ba4d3f443693df8b1f8990a2c9177b4c8f0d5fd1e1ef7ee63ef88474f4a3032f450588e3ff3edb9c381b7448be9c9a9b02bbbd0b52c164d7a0b13f25142f4931d1b56848c904c44dc9992dfd7caa5138a5303c90534ece6a50fff4117aca166458503dc5aca199f899f474f0ff28ea83b8da7fafcd60c462e1ff62547ca887d3c35c103bf927782636485987e90be9902f2bbec9794c6e818ab4b369ea7c1419cf9450d644d48b3acd60596615672b3456c6abed1f126a967f550d7ccf786781ab3313cac8195d97d1b3d1ee36c7e93023f8f1fcd4b67d1738d63fc22ad66dc91124c433aff06eefd80e8a70a501df02b4b979c63673ebdb89cfabaa8e422dede1de388609da1881e2ade510c0badf4024f46e4ed896e5d0d75af29cbbae20849acb608a5a22c4cb2a0c47676c336ee7b34a7cbfd47b909b4134201d651d83bfb5955e591ee978b2e0f7f2544c571d7cd680344ca6d259c2583531f6553b10dfa6488b0264dfd8ca78792b95d03b44ce9099783640993de93b9118cacf3eb6f1962f70d106113fd37ce54377f3486dcb3f5662ba0b54d20aaffa3501c16867fd639c8573a3a4f90e9dfdbf8931c9e52d8b0fe1b75d3e7b6e5ce6eabeb6f34a99e0882c8153d4d1eb96eb2168687337ec8e26541a128443d3589ff98757e07369bf51ec25fed87381a092af2fd9346ff52e4b7d7a00fd0321cd84e31a32fe92b6802b9622c52bcc5a73a62142d98f7740fb8f9c37e9beb15e387d3e23ad39c3ca5073c03a06de9a7ecb3e2c8944eedc6cb9811ebe7e3a502e5fa819a698e55b33c3a424870f0d39dac88420c44212431d1eb320b4c4fb5e2309c7ca8d1fc57ae8bd8f4b724bc9e8edaf74347856fc31b106afaceb91cacc69a60e56bbc8f6f47bd0c9f9025053d3b3d72352a80e6f315ab0864a7320ccb9cbf2f27c0f17ba036ca792e43f146d5bc37e8c192ff1cfbf514093171c1bb53f0528e1a0d20357ecb2a3de1e0f4ec5fe916f894141390c6a2e166d3570c10e73bf561859c060ae9d7550fd751ab276fecbed834fe0a16019655dc842ca2f400b8032bf3058dfa0d843d04a0848cb2e7ed75054a2daaa32f8eb2e1b15d208e0e8fc9de6b9ccf180de53f45cf4d1ae62fb1e1ac17fc502d22d10aa885d939799b93e85aa335c148547011d74d44db5515bfbbc452f9dfa8b635879a306e59e649cf78fc4c63341edbeb6812423387329f6ff21b88c53aead9403a50153c4cec14369a4bbbbde84d1ab7a51ea19a8214da5a14c62afb8b1b518232064797bad80db9507a29ada677c3f3f0c49b478c963f4d166f88cc2d8d7496aaaa2981c903f1800f065e9d21c89820c8add6a6a7fc1503e96213c60e6534ce5273c072acae3c055945ecfc9f52f9d0cd9bc92f9187a087197066026bcbbd42651ea88e440d519aab6750a56f3e59412921a21fae8e9e23c20e4cdd09b6d6e921c3290951b64984890f3eacacb390b841b53f1225c8fd3907c5a7b29cebfd3ae7bac4e0590db000a0e5f65c7a295954654e77dfcfb9e0e8742c5810fd9267c57748827842ae9853864d87a110871fc55fdd8ad9320d0acf23c7df8e74f247ee7172ead4ddfed2cc309e9809abff5c51303e00f280bdbe7fa8467e1453deec5a25cf86b77827bb7ee089a13ec0867ecb5087a40d68a97abe95252f2aadf2a96eff8ae8776d929a6ceff88b9cc093e0f92bc04c2e515f4b0c46e526957de78d0aeed805e6ab39a880d752839d7fedb1491506c174617a00f74fbe94fb3d2dc045fb22617aaf06d689747cbce31b41f4919eb33effa563e701ddfad74d9bbde6f8b0d477b1dd0597431f5cbae917adf2b2fdcdf3ab837e3fa17a973b082d247b545c4ebe06ba14af3fd9abd8f92759a2e389f4fa13bfea05a4a1b30b2cf81f3ac2015490888f195a22befcaed8528e254add32f586e6d9362f5a812fb25889f8118f11962c5c2df39bd7640c651872b5c4fd8a9fbdeadeb71c7fe2fa4cea8b2a8ac26494e12e4f5f1377040c570aa78eba0a470015aebfb7a089d66c6b47f9da501510b2c59c202ec0f2e9c015cc62589e3cb03e40118a791987b90c6e0b344a1eac96b84c6ad221922a6714803ff28b5a5ac2b31bfcbc2301efb448c734f42ea5da65f47f086e5baaa2d7f47f9d155215b04dc32ffad2edfc41444b919f8ec9c33ec06081f00421e35fecb17f45f5d8eb34b9143ff1092e5e80dc7745cdaca141e413de49b6602a355612ebbf4e6556dfd83709857aebfa29f39108cc906e1bab78509c494fecc8e82cc3ad58dfebc93c8e704add728fb1a181e55e5c0b4f63bc5a0c5998d637157fcd609ddddffa9241b1a74773ba21e0d8c0aee7cd6114e794dc3da89c29be8c68ce7be6fc737531ed3682f5092fbb05fcbbd604b71646ad7ba045e90aac2ca5143868be5fefb491f4b16003b5d9fd8f0e03b2329a24e7384ee452ef9fb8dc54c122c1631e78b96ce9c8631b4f3c6697a758fceb11a50b842da15021ee0ea1ed5b81f119c390824b3a0162087c9bcdb28562ab51d79bf256cfa11325881825f90c73bfbc18220119276f2291271b130d5b3b00908f1ccab316417801366f1ba6e4351b30f3280b6f92611bbf5e457e56abe6f71c0222467f3025bc4fa2113a7801e0483b7255a02bcfc52284abd75cca4c116451fa4451e2784194b9cf0fff78514d8e10c8f9eae001c8d9228dcaa08f4c7272486e51e0ae629c8bcd5e26822eca8d11df101a378d364ee4f0fd31c2397a28ed6cf57c71ec61557e7280d776faef48e8bf67f7a69ff4e3922f074f1963084ffb0f3c3a122497e6fe82da584f9d93f384a22e25219f330f83a785c8b898e783b0670f02421815ed9c5d11fd529fddd2275e548cb7c11569370c05820064f477772668fd31dcb4911ab38d4794aed8872e541e8440bdf467b4b41d500ed3c82426aef3a65bfa9248a2e432c0acc21c68e3e4e193e0bb97a2208d2cb44a796a4d6674dad6bce8aa0944f2f0b94bbd9362c72a4da00533f117a12a387c72cc01c8005078a9b4f88baf546da9c46977894e7d52cb9457976c0dd99bc21ba5667885293bffdecb26d764c7b001928ea25d999b624882221149f413dfec11b4a87986dce78db7775f1877bd915d286b5f3eaf9915bd35501f0fba2b585815212b902a1b504fc0302bf3686d2d3dbf7489d63bb6197f15796c25587c213aa2c3618e108d0e30e3e14470a051b4d12fbf92cbf1e54ec0edff63aa63a6404fb5ead80cb63eb73780db279eebe5a2409bd5965c73acace17123ca722081949baec314b3e1ea66e26f418a99605945c129cf8327e5fa4614c96a2e92ab499a657b6ee30f995231143065d57e3643836af5bb356d3ca4bb8aa339b83da53bbca77bd04218fddff8b4c6aa162cb974d21e4ee602cedcb177382d39988c7487a96205bdb95a2b5d2f2d816ed1d0d1e25d3bf022aa0aacc72756e0cc0c4738de128bef5f2ef40fd448d51e0ba54d7aafff31ea4617daa6fe8666757a88357d7355a7255c8985882656ce6e83690679f6f9c4c0b74cb6ad83f6875d66a5cd1889bd70ea4a0cca6f55c09f0b06611efae805e8e068cb9f6b84c1856407f5cce65421b4b6e94e2c5417d26401251f646df5631a8ccea91929d16b07332c1ea586ea5b90bd3c6ad8d2d7e56f513acea0f4559a4006f5e2efe735c3e26124a8afccaccea3ddd68071a634bb8bbb4eff360a766d3403c116df907cc127cd260c9149b9f90e6eab927f0272257b837e16572db7d6223b936dfbd199d432776b119b0944625236a237044a02fafb4e243b6644a7c5500c81ddc0bf1de62797a86664d032d736c68e8d178eaca6991e07e16f6c46770111bff93c47f9f84a5fe178ff94f927ce4d1908a06ec0be7cc1a30d71d0f794be563562d80ad6","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"34070fb5d5b87e29aac5291a9c26cb19"};

        // you can edit these values to customize some of the behavior of StatiCrypt
        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        // init the staticrypt engine
        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        // try to automatically decrypt on load if there is a saved password
        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

            // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
            // replaced, no need to do anything
            if (!isSuccessful) {
                // hide loading screen
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();

                // show the remember me checkbox
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // toggle password visibility
        const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
        // these two icons are coming from FontAwesome
        const imgSrcEyeClosed =
            "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
        const imgSrcEyeOpened =
            "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
        toggleIcon.addEventListener("click", function () {
            const passwordInput = document.getElementById("staticrypt-password");
            if (passwordInput.type === "password") {
                passwordInput.type = "text";
                toggleIcon.src = imgSrcEyeOpened;
                toggleIcon.alt = templateToggleAltHide;
                toggleIcon.title = templateToggleAltHide;
            } else {
                passwordInput.type = "password";
                toggleIcon.src = imgSrcEyeClosed;
                toggleIcon.alt = templateToggleAltShow;
                toggleIcon.title = templateToggleAltShow;
            }
        });

        // handle password form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();

            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;

            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>

</html>
