<!DOCTYPE html>
<html class="staticrypt-html">

<head>
    <meta charset="utf-8" />
    <title>Docs Template Mugen - Wiki</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #ffffff;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"],
        input[type="text"] {
            background: inherit;
            border: 0;
            box-sizing: border-box;
            /* This ensures padding is included in the total width */
            font-size: 14px;
            outline: 0;
            padding: 15px 30px 15px 15px;
            /* Adjust the padding to ensure there is space for the icon */
            width: 100%;
        }

        .staticrypt-password-container {
            position: relative;
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            box-sizing: border-box;
        }

        .staticrypt-toggle-password-visibility {
            cursor: pointer;
            height: 20px;
            opacity: 60%;
            padding: 13px;
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background:
                #323a42;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #ffffff;
            font-size: 14px;
            cursor: pointer;
            border-radius: 30px;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover,
        .staticrypt-form .staticrypt-decrypt-button:active,
        .staticrypt-form .staticrypt-decrypt-button:focus {
            background:
                #323a42;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background:
                #343a40;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type="checkbox"] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border 0.75s linear infinite;
            animation: spinner-border 0.75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }

        .staticrypt-logo {
            margin: auto;
            width: 100px;
        }

        .staticrypt-logo img {
            width: 100%;
            height: auto;
        }
    </style>
</head>

<body class="staticrypt-body">
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
        <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
        <div class="staticrypt-page">
            <div class="staticrypt-form">
                <div class="staticrypt-logo">
                    <img alt="" src="./logo_icon.png" />
                </div>
                <div class="staticrypt-instructions">
                    <p class="staticrypt-title">Docs Template Mugen - Wiki</p>
                    <p>Enter the password</p>
                </div>

                <hr class="staticrypt-hr" />

                <form id="staticrypt-form" action="#" method="post">
                    <div class="staticrypt-password-container">
                        <input id="staticrypt-password" type="password" name="password"
                            placeholder="Password" autofocus />

                        <img class="staticrypt-toggle-password-visibility" alt="Show password"
                            title="Show password"
                            src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==" />
                    </div>

                    <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                        <input id="staticrypt-remember" type="checkbox" name="remember" checked />
                        Remember me
                    </label>

                    <input type="submit" class="staticrypt-decrypt-button" value="ENTER" />
                </form>
            </div>
        </div>
    </div>

    <script>
        // these variables will be filled when generating the file - the template format is 'variable_name'
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "Bad password!",
            templateToggleAltShow = "Show password",
            templateToggleAltHide = "Hide password",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"69900582262351ab1448ff80ed6230e5b7b7d154ed7442135a0b6612d3dd713d76451c3811ae2f368c06f1a118036c6b0e5fad145ddcf3d5aee6ca94615d576daab28d1b6075ff36467df1b460c6b6e70da9257e17933208ce1d57bf86dc768c825de33100ada3afcaab94433c608c9f54fdb79eab004301ee13e5343d4f7557252c2513c0fa752f67dfac8b4ee07b9a619afe1ddf65774f4d603ea42a3828db50d99f98879664ce9e0e55be69e01cfcd9db84f1f9eab2de27c624ec7513db3b46cdb7d38cec7772cc3e19325225837f77c7ce7863d9d8277e2640cb0e05833004898262e6463e359e5635ca8499d0a7adfb3f4c37c6fcf13668f83feee9c64c4bc598936f8a991955ad6bd1398d0864e1cb487b7f1bd5c00f7d2c37f7896b02732459fd65040e668074a53ff0e546de99505ecc0bf31547f59c8e75bd64cce9af3d862a2ac2f5382a8f36800e65a7a51a0acdbac793ba3fd9c7ccecb2023bc59999edf80c94210ef26f794e8c617eab0ad14ec496f88a2b2014f109ef3d95198ac665af3ae55e333dbb31eddbd87057ccdc249c4c145126060c2ca5e1d9390f1b1290d87f1747f0a647fa9353e40bd1c0822f90502038f357056e0f286f170995f19112a75ad01948ff98b05f88d4a8b8ad3dc9676e65cb91cbee1efd064234dacc198ae4801621324820b97585bdbd6147a5772779bc57596b2ed206db155e6bc6e71dd582e586799ced4ade633d5e9d6ca882f4dd5afe540290dc23d7b7d1ee21a45acefcf264d3ada7ffbaddea0954e3c173b6e51168fa562aab9ed920d6cd2abd23b6592ef6e71c0b63edec2641b991bd91af205e04b210149813c18a5e83c32c127f1182020ca7340f7939f9ddce393df57319e903b23679e0c6a9e3a6f12b3ebb55aa7a9ad11f8ce0a7e2d5edd5727b97c97d77e9c4592ab0ff9704a687cb1199eea2c7d1470729a706970608bcdd9a80a527b21314f7fe96383b26887f6c4bc3fe32bbce4e3dce66fc2d0c707143744a938babd0751f5a0a079f61eec83c3ae005857b69cdbfea4e736ba353fe594a4addb926091c4c1087f6f6d9ee6b5c167a156a808467e2694067c9c5399161702be1b781adae773f3879f27e08d0fd2eca96d0cfe3d21782807142b276aa52dbe93ca86a21a8958ba6a9ec40abd27df76b38ec666abbe8c263551fb2feee7ed5253151601ff6fbb0a819f89b5d127d1532f650f21af1e0c8f6b51505a234b6aebf84e7849a8793b2a802b7051e153a792793b966e248f24be69b8c9f37cca15b51299aa73633c5f0e83d10135292498f656892ba8bd48568f1bbd2b171d20f69003e21b90697fb32ddaeafd28d3251f226cdd264127ad879ef2e563cb4425d22afb61a6ffb95b3c08c8a2b404c629d52fe4784bd0f6fb57b811e91154b49223c5e83d89f5271bb6863de61e60492cb9ce0208b28e2b653814cf3e0bbd2d53b10a222e7045cd0d58232c4ee644fc53ae3b4267c0e6c193765c9eb1dada5e7d588be75d85fa0743e32a8f346307bf5dabc5a6fc45982626d00ccc0ec564d2c9794163a919a5991227c8d6beeda43667485193f4880383b85c5b1c747f02490314eb693dcac1b19fcdd38568d4473409eee4e0ab945468d4de6768ed9e51331b25de6b3cc99cd1ce31168bfa59051279e817fab10f36b487403de3bf9fee7e828ba7a2cf3e51f5e68e511ee57f969f90b79cc25569d8e5b3254c71c115725ad89ff177e0db6e9ca535d59eef5a55a4fd0320c4c7b197247d74f7940018b486353c8616c6b5e936cb1152db86443d56022eb45d501a413783adba7305c644b812e21746c7f373291d21f3c393b93f31b23c6ff3b4b3f6c97097c764dc52572f977c296428f7aae751187fcb90b5e8ea87a077a3e9048f61486410a234440502d3a364ddadca5bea3a0d12396e2b32bc33274a650f8c5da7ee4fb80a9138ea113089f7132e3071721e82d50d32e74cf25784f2e62f0fe8498ab69fd60fa95acd6e9f31248c4fbcb62f10b3376c5f3bd13cb7f3e139dba92d4847f8dbfba1efa770380eb43c1b75603853992cda261ffb61be96ba27c2f41a6f28b568cfa54ff7edb1c2aa07667ede43247a56092c808b31da27fc4c414833518a21a78110b5b6b5eadb62c56944a8ca3153ce2b0052174fa27518afb842eeb7299c84e5c6acc1274f4c281d9f49db9bed4dd946deb13b54da23012c07c12873f1240a8f9c06c5099555125afa3872b9f91fc971f8b11a7723eb7325d81dbbfaf0c5108636d0a134bdb0c964394d55ef190ec6b18c8f4b8dc11ac3baf70c9d6e975b25af28f2268fb7f73552b6343a4e95cb15d67cadf2c89c6df43c3e56a0029417535151db6f9822b6f1c0d9193533f499590a5435ae826da570f9ad7a8580b205b43ef58a56aef2d4e37277fa533cf39b196cd9d65e9e7b425cbfafeb7065ca216c1dbfc17568823f46515db35cc90a22c1b86b823fa3d184c507ff3b08f4ab33c83e0283f2e08cc949ee6027ab55b243852fea1b7f1bb65d86c6a7446ff1aa11f64f7dfbc4f28950484c5b443a01e38b7f09113a9875cd24b098fcb5cf87d2e3eb7436c4c83d8186c421865feda4736a847964c183d167924afb472f32b966cd2a271c40ea56e280b72452ea0db9a669a2bb07d96f55da86c637addc4f8f6bee17562ea728134f5cc1eaf45bf9b44ad16eae55abc630f606a89fd229e9a49f61a806b2d3bf26e9465680cdd9c1cdcc4bb40a83ebc3a2fc4b41ba71abdfb648f142d4603a8e5ddcd374561d707a336281f0c8904bfc711fed01411355eb3cb44410cd00d9481aab32cab5b13438b21af467ef71781f29ac80e3d36259697b475f61882c088dc37c71e7aa18d722362457d32ed8ee23fe111bac0c5d25672a07b78683a4b2259c93183088c7e7f688a67348f84703a5d18cdddd62b326bb19f345568151476adab65d8501ef64fd2a5f28462a55ed7c401e062d7336f7fe5b805321edd9d1176bb7906da35f2f8a2a1257d18deb224909a6e13255eee07a8edbfdc539b1d867d8b80ad86efd77adb28dee787e7a3a823dce42199c90a5e70e10e06d6923bdc189dbf8e4404f67731214e504695baea0d175f23e0a955a8d5bfe759455054f1ee1daf123c6df835ac17e3f8933d4fb53b3e1be4ab9ef0ef76d44758779a7e1fd6db73520c82b7d63be22cd35a97dfb2572e3593a03ad753f842e7859368a5dc1cc4604de79daa78f64b468ba4f9b861dc11212e553bf4d66decfdaa0f806f02c31dc44bb0d766960843b5e3f778233091fcfbf7793d75818a4cd6c26adeaa923edcb384c0dc63c1aa4df6fa13ab33cd5fe0dc31e2dd10e6e299ab3b3e19c781dbdb9c6aad75f890ee0217d61ddb3e69e16a4bc107c8dd876257bdd799d2cb0a635cdc314621f803135e0afceb65eb9146a395304b375e8da7350b125131d986825381def76f57b92e7506e109a8ddea50d1a875a87dc0af64f0bc19a52b373782ae6fd9219bd073beedb6a19132154c1491b556edbabb2e8f80554e8a7a0f148be6b90b82e8cb55c8c5b173b1d2bb14a973d6c37bfd2a659079212456ebfc57b220038f8f3668f2006354ff4cce349a3dba2b4920c77bb2492bfd1c2ad71eddf730a8795c654a0913d772e3d33b0ae05988295a952093b359bfee694acf8abf15d978d21762181db3fb1dfeb005ef85407aaa5f0820d427bae394eec8a9f37a1bcc885e932e5151a9a9c506fbab576997bcd39affdb2d4d24b51cb1d759507a8e27f9df3ec30769a4126ed94359eb21fe166f9e39f1ca3a3d4c1a7763cd15462b5688a71c95de7a0e86fa1dc7065de84571dd154af1f601f71c14809000ccf612f77ef41f91c4f4f533cd41435e39876e14ad608454d3e85a0a4df3b39bdabd932e763c99dd1baeede8c482fb9e9690884b49a9002d940ba1173103e6b7e7e9f78a21d8a8ba8c6c42b434cdfefd6358d51fa7ec5e811636241b14965a5c8db9be412c960e2c0897a21a5304fdec335da6f1374228f5e0d94bc2cbc8151dde81fc14732b060f3a6e880b6b37415666e6f59596f046bbf7188eb64d27883c20c6c2764b4be00c11c5c3ac10084dadc3b43566bfcb63048a45e9791211442a88b52eadbcf338c424695b26afb276275c9c4d8aa192388f082ff975b153d25cfe4802f2d559146bc9c23b783de20d7e00e6ad0ba7d27d374c8d7f673489c99f6f0f8fb8892c23d9ce944fecc21d466feeaf49c0a2c031de4984de78ddf3caaf12e087352377ff9e6f68f52f0d7bbf8ef0ebee538b11f0ffc1aa4ba175f67eaeb52df93045f642e0e730e44983c4106304cf449f52de31727711d4861c1c12f74208753591e2c76797a5b52f9a9bda724b64f3443a1f01b3d2c0c12f606e2c9d3cb3cc1e1b94715107418b959d061ba226e254cdb34846773f107eaddb22f71240c286d153c72237bc90398cc15f56bfad2e5c42c136988010e2e97597980d1dcb4ace3145f927d0640b7a54fe60aa8c8ead87687f0c8285f1907a40cdf5c68c800522152ebc64950572bc7e4bf2826521a63a811a0877d03fc1b1157e55667e5b6be725b165d66e7ec13a8945bf15551236fbdd21d9d01c87da5588aa7c8592c55b3b443e2b798d3abbe39669e7243917a7d80caf4ee8313749d43112edfa81d057d7d3d970618171e1e8b3a5997fdfee70fbf7d37baae55e36babb3eb90ca38eb345d0a4b95efb64b44fe76ae8c595a24bfe2705608587d56e93bcb93c79ca35e44d6080b974dfb512753663155ca47c92ce682733a37bf8d6da9ec4129258808a215b42281649a9508029955a8df6cab2d8e0531f6d419746186f6a7e2733adfd56ec2c71affc4e5db91a0d0dbc5ab12e0fc70703ddeae63a59fe8e079a0e4a8efefbb61796a3851878bc897fd6c437f9868bff07ce53c709037d6cfe1eee80340f949c508331014c071d5dd632b8101b5249acb01b27f199ebafa69370c8558e1a6f434df9b3b37e0ed06861002e66cef3da7970196e2e0072ccc614bc6cec337c71b764d8dffab2d1eacc00cba0fcfbe127d4826c246725bb5b57030d63ba8be01f273698a4fd60299175a57b6856fafa1e0ce2808f0294b19bbc9bcdc0f31a1efe5d726cfb258810b6637d047a63348560d40e8cb61c68fd9b59c1dff5ec45981c31a3b4f145255148385a7faf72a2f66d24329a1b7b7991261666ab168e69e554f80561fe7dcfe1778bac1873b701ec7f6a5cd14943eb59c5fe07dd23135a443bfa39bd3825fd2bc330525aa52f82f740e5a532ad1e58f6e9e861445a3f08d5c1f22a8e51739c16e50390b85587c078a816c9cc99dd3823e90feb9a77a4f10a2b23c16002ff2a86bf35dbf27fd7d09de6adbaf9deb553f723ea82a065c3f4bbe2bb2e2f318183b25d2e30ba268bdaf7c37e1c6f58652875f749e4fdd26200e42b7233ac9055d808be19030f82ff4946bf615b2bb6043f78e54000bb7a78a4e19a01f8a81fd96b382cbdaba961bf67315ff16a83100a015071d5a54c4d7d0d20affba830810b45e5db3b0511b0e8974dcf581f5ab5939bd3744b896f1eed96d6b851e6759b4aa26e3858e5c543452d60092e56f7732407413dc0ffd425d1d3d8b67c8c973552ad0602119ae92e02360fb715871e6d9f5a31eb8332174201755fac538d275e7cd30828b2355d2426ca132f435f20d3a910749208f7747755a13a2220bf339bfa866b5b5d44df468047e77c8ecc69d24870922ef8f2a3d66c002bef8b19fca545b51203b7411998ef923943265b35a828f75e8dfb9d3a275ad373036fdc2214c510702990177936878cf87725cd4cf0ccc734bcb8cbe251a1176fffb881e35a9e44fd84bcb6bd7d743ab5e989776da8632b7198d127fa3956a96801b932f078e7aff1c7466bd277b5fce05bfb92565bc94885a54b70cd78e64bd955c1c7c4c2ee5d8a4517a8f72e5ce84dc13d4f8b75a51e81042aeb61104b2216a942984028bfc316e6cb306b1886987750a19ca7373745fc1485919048f000e290b75e935813a0208966e38c3857c9ae704c9278d46f14b07151d154867611b479b6e0caa1b144d2bae5224f240b230ac5152cabebe5b9a38ab3a044ee4cc32f341092c09b774dcf06c09aa1551e6d3de39e3a5977cee006fb38f4705bccac32594d910d86f956437110dabb7d1d1a56d7486972b05c8241e46d6bd3e82fb8c22f72663946c6b1f7b18d1d7e769abc906d9f8cbb08b4be7eb2058940e8d4aac14faed1f85ca0d2e367cafc10415986fe95ab92b128f6dff23d746c77f43075dc32ba1a04b00007f681268b152aa8c2171539476972aeb6c693959dd2e83883e8712bc90bdd728787d51eba0b4ca45817cf991c1f3a57e508fd52fabb2b3fd82a5f7b450f3085059df842ac589623dd349018bdf917f9a46e1ae7b8dd077a1a9c97c2fa6753ebaf9751f90b160770c6dcaba3dd4336458a7c08e9075dcbb580a95fb5a120cca5ede067b63b103db81d3e0a3bcb901547fdc8456e93b602582fdf5685a3b0792704975b729d075eb38caf8316a58caa8e77bd2b13a2ef98316a88afd67096492374a9c51dcd517b8ccd058aa19ed293a3c0d0800363338ed09a61f66528070dfcdc208bc9c09612cd2fe097e013f5527ac4e95d56606578fdf64a3f444f19702b55e96171026b61c157a998a52cc591ea0962b7b67d0fa7521c611ccc9cf3f8b92709fbf738677c708e01c121a27553e170de5bca1c5f15f02e28dd6db98bc55e6309ec75687acfcdf1e15fdd02443f47bc930b7fbae383e6f482109e5ac4dd0e3d7a862d6e5b32952cc23227fc2cbe0801be9a7968ed2f1b8b304f3d842f9fcf7c389d759ef02a7ab8a51e48237e28810ecbfb72ad4277311a5a5cc08693e356338feb7e32d249db4c289d4d0ee0797e6c78260303f33a7c9919937301b8c322e1d2482298eff13747d3398e587d7daff387ad20b36961d8d7d0ce08fb2b4286197c55c7f536bc03ad0955859722c55c151d1151631b550a51e73644e04b4b59d67a2815cf9d8e1bdc8239cc62ca27a7f05580307751d9322e200b670800a3fc46ee6a69b56811b3d3b1e6115fdc83152681dc7c575375e08c145690530f047e7f55260bdc3635bcbbd9770193281b633ce120c3c820025c65bbd4d8454248fa0c4a143a60369f067b1822665fe18483596094eb53988cf9b00b2f4abb6de007e04ec782ec44a5472dcf531df49f8d74d475fd81bcfb9026a868ec04f3f168b7b70f4bda58d14bc3a6","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"34070fb5d5b87e29aac5291a9c26cb19"};

        // you can edit these values to customize some of the behavior of StatiCrypt
        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        // init the staticrypt engine
        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        // try to automatically decrypt on load if there is a saved password
        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

            // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
            // replaced, no need to do anything
            if (!isSuccessful) {
                // hide loading screen
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();

                // show the remember me checkbox
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // toggle password visibility
        const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
        // these two icons are coming from FontAwesome
        const imgSrcEyeClosed =
            "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
        const imgSrcEyeOpened =
            "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
        toggleIcon.addEventListener("click", function () {
            const passwordInput = document.getElementById("staticrypt-password");
            if (passwordInput.type === "password") {
                passwordInput.type = "text";
                toggleIcon.src = imgSrcEyeOpened;
                toggleIcon.alt = templateToggleAltHide;
                toggleIcon.title = templateToggleAltHide;
            } else {
                passwordInput.type = "password";
                toggleIcon.src = imgSrcEyeClosed;
                toggleIcon.alt = templateToggleAltShow;
                toggleIcon.title = templateToggleAltShow;
            }
        });

        // handle password form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();

            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;

            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>

</html>
