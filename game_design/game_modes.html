<!DOCTYPE html>
<html class="staticrypt-html">

<head>
    <meta charset="utf-8" />
    <title>Docs Template Mugen - Wiki</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #ffffff;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"],
        input[type="text"] {
            background: inherit;
            border: 0;
            box-sizing: border-box;
            /* This ensures padding is included in the total width */
            font-size: 14px;
            outline: 0;
            padding: 15px 30px 15px 15px;
            /* Adjust the padding to ensure there is space for the icon */
            width: 100%;
        }

        .staticrypt-password-container {
            position: relative;
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            box-sizing: border-box;
        }

        .staticrypt-toggle-password-visibility {
            cursor: pointer;
            height: 20px;
            opacity: 60%;
            padding: 13px;
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background:
                #323a42;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #ffffff;
            font-size: 14px;
            cursor: pointer;
            border-radius: 30px;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover,
        .staticrypt-form .staticrypt-decrypt-button:active,
        .staticrypt-form .staticrypt-decrypt-button:focus {
            background:
                #323a42;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background:
                #343a40;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type="checkbox"] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border 0.75s linear infinite;
            animation: spinner-border 0.75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }

        .staticrypt-logo {
            margin: auto;
            width: 100px;
        }

        .staticrypt-logo img {
            width: 100%;
            height: auto;
        }
    </style>
</head>

<body class="staticrypt-body">
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
        <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
        <div class="staticrypt-page">
            <div class="staticrypt-form">
                <div class="staticrypt-logo">
                    <img alt="" src="./logo_icon.png" />
                </div>
                <div class="staticrypt-instructions">
                    <p class="staticrypt-title">Docs Template Mugen - Wiki</p>
                    <p>Enter the password</p>
                </div>

                <hr class="staticrypt-hr" />

                <form id="staticrypt-form" action="#" method="post">
                    <div class="staticrypt-password-container">
                        <input id="staticrypt-password" type="password" name="password"
                            placeholder="Password" autofocus />

                        <img class="staticrypt-toggle-password-visibility" alt="Show password"
                            title="Show password"
                            src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==" />
                    </div>

                    <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                        <input id="staticrypt-remember" type="checkbox" name="remember" checked />
                        Remember me
                    </label>

                    <input type="submit" class="staticrypt-decrypt-button" value="ENTER" />
                </form>
            </div>
        </div>
    </div>

    <script>
        // these variables will be filled when generating the file - the template format is 'variable_name'
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "Bad password!",
            templateToggleAltShow = "Show password",
            templateToggleAltHide = "Hide password",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e4b2625f0afc5454d39391bff9c2177c16f646ae09c63d18b47d9565e531fb481ea13a42ca986ca1c171a7bb40337cb1598714484dde28547c03aede4d3a2eb64f0d65ead21061be1ff03ecff951efd87583ea39572b9ffc90575bce279f9d1c2f2e09be4d992945345075e806e7f4a9171a51e5c3b4f3d7a61082d854767501485e1e4b9bdc084a9259e25068cbde9642c3da1ff4d7e725cf31003370ff03dbfccdc0fa05ea00ea273e93053e88079a10d93333904d616a2fb0a117d507be3162b622af301b0291b5fba3c449e8888593019cebbec6b33e2fe24bf1ca72ec1b0d3b4fa5752279f8ac44fb49c704ec22384b6f577911d86f65b2f6d2edc52df28df40263db75e72132b18edb986fd1bf62eeccb3962a2bec63896aff409d7a98cc591b239201af6322cb529f08480578f9e95f8246a9f403f3af3afe12c7358caba9c5e3842c3921a0a3b3bc17d58d5bffec2244861442b97d52f0498958f25b98ca70394c889428daf16e8e99e92ebdf3cd74c2d68934f4cee6718230214198f04c9069c157f31723d873e19f7c4ccb6eb588a18e5471e174e52507391b46936b8077c34502bde06ecb41c9aae8569a5160d7cfb3c155224afa3a99ed601e92ad574026c8aa1e3bc7579f2d3a2f8445e4a6966d6fc6f1d4acf33a354e688b96d755ee0feeb410f24e6ab3b32faca39b3e11bf9c57a9eff49c1cc20f50b949c4f2467dc4cedc6896c0315c978e2b1e8fdb6197668a9a72a2f842a5458afadae2c917c9d332768094500af09ccade0a1ad18dfafc3ce1e929cedb0db20c271902c3861b9f8bdbcba234f5371366892abfc4466b2d7729964c3b74ae832292a388dc9bcec2f6904627e4b5b2376560227fdddd7de89e109a593d8323febc4a41a57554e8be4aec55de62f64ac5a38452edc3ddb9ccc25a038dbd5116c88dbe686d25eb1c0c28a9f6b1e8b09d3e9ccd7cb5e391f29945a0339a2af05e74563a20fcf3c432703a1089a0777d52f06dafbe2110a4320c4f0a34f9ba14536692dbfb5ce06fe35d573c9b9877a6acadfb710e4f8af73eaaf6e9c83538db1ade83c04099870738101f7561338abf7e72bacbc42c5ade19f3e69b8b94685668956d522ec8f6d214f2ccdeb98ca42ddcac8ef229f8bd589b05edab4c51d0be3da0494cedac0ca08e863fd57fb1f90e246ec6785cbb412096c141973f61388b93ab7c4a2897e4290a7fa54537a7fbe62585c0f5d016f723baffd7c7f6c53a9c12e27a631616b17601699642300038056f57de2bbe2e55888d6dea27519d1930d1794a287e96d4e7d2eb7a77de5d295b5e6ee4fc3732bee2b695fcc2b4d75331726e3789ae1b1b4d66a12da092de5182dfdb5ea0781118c526851e41f83b37139a421030b8d94ce4be5f4898110b2ccbfd46ffef9f6ea24804bab0ecbc40cc6a1743d5a1a0a1f95dc9b1081961ccb1d60b0ac60cb5d63a27f8195ae04302a9ad800d751a14111901960de5e6dbe2841912db097a76bc55d004d9807e23913dda5394b36cb015ddba74b54f5907a920ebe0a110fb1934a629faece255c6b1958c3b6fc3817f5685f9b011a2b5976e1760468f62afd0057591c207339986058b388bfa5203c33499db4e9dbdebb55b069c4e3ffe1adb04bbaa6b2c8dabf20e05bb661780a4f56d4b4e3daa8bdad66822e20eb76a9c7f10831a13c3090592415375f014fdacb630884a35ed7829e3a2f6b7ff3750f4443188f95bf61ab3be23a23af6f78c4b4400201444dacf3ebedec9716bb6064b861869a39679be016c514519d94bf81ca9fe0edcd27b0b2299058e6eb764bd33e59bc9cec1fd53b8f96e5ac8dd942a424101511969523c5dfdb105b0f344bcfa8f7ac0ef2cc63290b1078aadfb6d64b414c31de1945f9048caf8dc9f9a81da1573ce871c7c1cdc966e0d11fab6cad3f040402c365aeb1e723571ecbddcd42de0b8a738142fbe797d841c80e3a83dbf83b6a9c001146428e68cad60fbb2b6aa54deb76d581cc241adeb0a9e9f079f165eb9d291cdf4d76305fafd2dc204765293fe9e392ed3cbd76854b94ffa0477d88ad86e230066a2a84c2eb51854728de77c198b3f639af7775e23c17e63300e05e1eb438f172884b33b56152f6728795923775b3858a498a26bfaf423ced5510a87d5b700826b378eaf838e950e1a1c2a2f37ea0eeeb054da7db579c9d48c09669469f8d7550c3c3787f6da943169898abb0fe6dbe39aec4d11afa602b3a5e8a172e7cd334774c5a40c44be1dfd82abc2369fffa65375b129c7fdf92bf83be676bbf2b25954f974b4cc5b4e04a40588513c4c5f307e4ce834512270e77028a9d820bad62b55d3bd722b26979bc8578750a8aab8cb0ac7149b0d4aebe70b2d0ecbe2b688749f0c61222e6ffe911fab5ef3f54c7c3420c328e71d17cd1926e12f37861b593af7ec93e17c7faad71b92770aa0ee07a1af688f3aa48edc933353b961cdd71e48eeea8d6cf02c9ae3a4f7c217ca6ac3bc3b0cbfb24a0ee4a0b8f938c44de839353cb9321aaea66065641398770cd35e486498064315d6059cfce33fdaad276436defde1ff8cec07485cc86052422113ec4998ccb210842864aa13fa21a06bd4d6f8e2ffc5532b1faeb7198f242b8acef399a47f6d38ee863fad1693ef2aa4eb10f9396e5159a9cc3413602f284f31a2feec928a0deb944f619093f3e37df3a28fd5c2f70fd9237a8dcbd762360535dc4004b6b4ba83df45969e6b3db8f2a303bfa4fadc8a94070e4f632dc77b913d33036728546cbe4d8d79cd8f44117b55798c56cbdac4819ccb01ff9b60fb4965c2c8c0708973e8e360d9b6b6a726829bb30b4e4aff14e7e0e756ba6f7d23d16d84cd260a24e5ac87a27d07dfc0b331404eda0e670aebba61ff4e6e85f9f08854342681a602d9977c96deb3b38680f2af189f39485224a1043ff93f958b909ca930323f96c175bd027f65967cc5974a94be6e63a53574c71a7ac13d46b17aa496ab5274027c4f25177847ab2d008749284c2c4c87d5d42f2536fd72fd6ebee0215797dc30a2d36061b1cbf1896208ced3fe89441356618d3549ecabc0051e64a09ac07f2c7b1e6b769a2f44cd40679fda76a3c8ab4aff9d9308d63a97896c159d56b621304b6e18af10357b50df947b4ae64fb7742c8ea1e32c53349b097062337799b3f76df773b6647fcdc38379af1a98b212fb57c0c6d6cf7c44db9a457ee06460b404b86167e90ac08be8c7ab3b874605eb4bae13a63bf29921acbea1c5b32699583923ee0bbb7a83d2c77c73dda56672f8914fed688c964e38ac52899cb03daed7d230e60bdf6fec3620ff31a5ca638f705252cdef3b98ef0194ee3bd95266f4de41d62dd8632ab1a6bed497c325b901750333cd004db264de6f71339516e9f0516f18b0bdef0f6cc0f75d6660a4c6d3b2037d2f96a9c8984f24b7e3ea8c62dd157fafb4e246a9aaa1ad1f064236aaa2f6e3b344f45eb67fdd5ed40ba89a818b983a744ad9b5d443446ed057298cf1730da6bf2e5b41ebe0952a168e21cd1a1fb51d14c355d1cc1e4c77d83143ea9a2ffe22e8119580a28a0d4de354170f8ad019733a90ac4b0728bab145ce3cd9bf3184facd9ac5a7b02b4e20fae748e87cf1937a0de1078a5a474ec73b26d579738809508f535e8706c160713c4620f8228a4ff8c2a1e2372d7b81ceda92a9a8e13b3cedd201e1a22106edef6ad2009b0a8cfec77a8e1a8fcb5d48366f4e731958fcf5dbbf7704db6e1af8643e42b21083b2c47e4e8d4d3d435f015eed81249346f7cb8a8ec9fd4d3ae49acf16b390ae3ce83b79dac9464fe38405181eec7b3c98a4dc5c06fedd147612817d211051e41ec6efd3d152344f01348bd02aaf1342aae09cd746c1653f235a171d6328f7f4b18ce4e46b0af15e83a8a39f6a002261d0a13c64de769cb5ebaf15cf49620f4f6debed030d0694e655c14ee859001ad6f47044d27cb9f79066033bdd606c5455fd35b2425b3d7c45cd8d0e4f0676d7e3a576d0c124578fe2a052dd3424f8c457c472306531cf2ff96c975eee7337a06a3deac8d3679867a4a39a9dbd9b69e82cff877e5431e278e44061ae14e93e0f3106d754dfac345ccba830a03b8ba6645c677202c0229dd1db4ac796ad08b3ecdcd0a35f165b3beb1ac239747c11999c050b4c70192c7941886748617bf8d0da4a3cc9ba36256ea83aef896f57517474defad0a7ae3243d9d7ee940718f037664dd2f5943a40271be7f195428750ae096515d503fb70a189e290c4054d4bfeb41873bc6222e6209c6a1e17a50c15ce74000bdafc97c82a352b8f2dba587ed1865939f6602f47baa2d888ad2e208d56f6ac601bfbf749b0b53e8391437354e2a180a57dcbbc0d812236dafaebb456f29dd2a3fa5ca920c48e6889af5b3782d559fa3de81227fefd7e4689bbd88302506283737ebf9f137cdb3d49f8882e806a2dc906604d26fb96b6894de602d1e38a119d110130bf1ecd8021f28d23f9dbe1870bff40e72bb67c030ecb0b883e23479a38113a62d5577c48617524da563c9d6edec2ac86ccbf3b3d2edd207cc04fbae4234219c590096ea52d7e8c1cac201dabc9e500c3663a9f09f5aafed25cadd64e227be26402c4741d82b74e231c6a80ff2644315ba8ec6c7abc4c4441ce9a7fe9c0b31a8a69259521a9a043f8df2a2f69c07fd40ec3c34d5247946a9e029badc2f495f8933c17501cb8e506c026c38e2a47381a55c9ee1c024a04383764514814a021169fb246bba50050a6080b9774786ea7af845b939cd60b329413a378d3e43701fcedbb9a483e4cd53b2518fb704b9c678159abbb0ff8df72e36503addc0fca4f758685dca11c1c5687af2bb15aa3f75bbd7c9b8a6d979ecc832b987d2c166f8b6b07a67e027e7b70968b83dfc022fe3ab3efe29b265b7b4abe5e729b96f2d39625c90e02f97e5c5fd0ad261e6c259c50a878302b380c8bdd707fc893ad2d08f000dcad4c73836c569440be47725e41c5954134a8590942c95e8f520bed9a9aef99a482e738f5513edd7e974a91e6b84325ef426a2c451426a9d586b65b569143381af528bd991db290f11aec7bbc1e842a73b1f64e3dc24d3a9f2724e9cd90082349b119a66ff3c1615a427a87486bc85ed4766c0ba8cf92a351b69f51c4d1252bde407033fca218850045df34e7df65e0f623da6f39663f9f27141f3d2e9e1d433c8f395b81e3cfe3498836a3e639d7818e5867ec057cc35978588d5ac0a792f767aeeae3cbf354da9533c0487b09bd664035f5327c29c9a04c2ef5e8da216989d1d99ef767d7d19dda03d6cc421bac8b1fd2c5ada21954114792ea7cea298e189e318984bd070469c79e5bbb1001841061a16cf886b254548014be3b46b3ce38cf840c23259fccac63a105b5dde82907c76830c23052aeb33470ea69b319fb6fdf777e514326e0aeac5a02839419ac874b0de1b305be0c6799aebf820f1bd129b8e4a1557ed9e2121939020882170de8586da7f7812e8832c67a0573664e32e46c49ec68d5bbe9e79d4a4ca0c556930dc130de42a44dc2a8a56f92d5c65cbc04516e99ed400ceb845984559a9ce9619be1efe2a372808e1a415e85b226d72be044cf28f34e2462cf3b0bffca7d9fecb6696879a096f601f81710e79f95d5eec20bfc6ba32c0e442ee85ede9ce10aee42a4473ad210f74d352cbd71b24802ece5de85ac65d5f334c7ecb2117913c5bc35e63b1226748618a543fc1b6821a03a0ee5625dfd15ed9ff85e684715fa739cd02edf73133897697961ebb8a036fed27e25f4ea5ff842682596baeb6161c237abcef86d28e86457bf1f55c70bac7433e767b1778a5fb3f0d013d85fa56e01da8175004f72246ab77e1ad1daca0886ced61e5787329e96d0792913590b5e9e0aa4828c5f37c54682068f7a5e0ad4df157301c5d0aa709df75b5364ea0c98b9e080145bb4f0f33bb836cdb01009da781f635127fbede5037150754680b01416847e064dec2121194c6c8742424e3737062c19fd286c874b3817afd77765ab3a4f2dbdf2bcad4730d4668d9810e958f2d8586cf7e1ec8fbaf872d37d420639ee46e12dcb65b3ba3d73b7cf7a2df9b3bb470640afa15a0d30f1c523c7041b16954c5c97a894828f4c523b77fc29be6839944fac3c50b434398472475ccd73a469d4bf0e16ce1f76f87f4547502ede7693dc96cc54b37f7e6e5e53d7617b19252c9ec178767a2b7571197f7163b8e10c0375196ec508583f7ef9ff0050bbf93f3b04e9223e17a832698054d555c37df2034fbb651cda9232d5438d7ffe8d8c3dc3787f864d20724528a06e36fc7e75be4bda7cc8c33442d2af9ca4cb2eaea25bc5931f7c7f79c1e4a6f26073eb799fa7802176c804d0fc46946060fe3aba6d933f77853f761b34b8acf47b7beccc0509eb28c13641f1388164b0dbb3cfcd1607a1b9db7317600ddffa87ec2c1b5b8c11607879565bbc30b8491f5a9579cbc65ce922280b241aa746a1a434d10d1c51a1be337ca8544bbe2340327eabf53607d2c96d94ca150634569c2724292e26f32d7d92ac0bc294a3fba1fef98c82900369b15bf87286aec9bc6dfecfd14c1d2588062326cf7be342923eb82fdda57ed1a5da86aa4f46e6e35bb2745f2049f9c5e7da1260a13098c44a0b7edf49a03eb3b9393bc8a5a54b63e99fcee69d7eca343d665d28566bdbb427f6ee231508f4126bcfdc91d1852d19e5a4aff25d7a7381ce641772dba2d808f7da316e2c048f412f8593dd47a52741049b8858e2abcd1152e12885ac863818427c16cd1e7d99f0926eb38e6d07d69cb9c761424f055e9b0c337527837e3c639e641d187f4409270d24cbdd6855630f0c02e5c4b93866232ba78b9dec535df3d2167a2df1baf4f86a223ec3e3cb99a32657ee48d744b5986133eee71c995eee4b13fd0c74c6f52d4cf982ec66d5637bbd780785f4ba3bf8d2eeca6b250169e1369b38f3068b465c4a4ca587253d493e2d666bcf52f6e55101b9499b68436a5b1c663ba64a30fe94d34e79","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"34070fb5d5b87e29aac5291a9c26cb19"};

        // you can edit these values to customize some of the behavior of StatiCrypt
        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        // init the staticrypt engine
        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        // try to automatically decrypt on load if there is a saved password
        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

            // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
            // replaced, no need to do anything
            if (!isSuccessful) {
                // hide loading screen
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();

                // show the remember me checkbox
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // toggle password visibility
        const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
        // these two icons are coming from FontAwesome
        const imgSrcEyeClosed =
            "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
        const imgSrcEyeOpened =
            "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
        toggleIcon.addEventListener("click", function () {
            const passwordInput = document.getElementById("staticrypt-password");
            if (passwordInput.type === "password") {
                passwordInput.type = "text";
                toggleIcon.src = imgSrcEyeOpened;
                toggleIcon.alt = templateToggleAltHide;
                toggleIcon.title = templateToggleAltHide;
            } else {
                passwordInput.type = "password";
                toggleIcon.src = imgSrcEyeClosed;
                toggleIcon.alt = templateToggleAltShow;
                toggleIcon.title = templateToggleAltShow;
            }
        });

        // handle password form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();

            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;

            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>

</html>
